//go:build postgres

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package internal

import (
	"context"
	"encoding/json"
	"time"
)

const claimNextEvent = `-- name: ClaimNextEvent :one
SELECT
  id::BIGINT,
  created_at::TIMESTAMP,
  last_updated::TIMESTAMP,
  topic_id::BIGINT,
  state::pubsub_event_state,
  cloudevents_id::VARCHAR(64),
  message::JSONB,
  headers::JSONB
FROM pubsub_claim_next_event($1)
`

type ClaimNextEventRow struct {
	ID            int64            `json:"id"`
	CreatedAt     time.Time        `json:"createdAt"`
	LastUpdated   time.Time        `json:"lastUpdated"`
	TopicID       int64            `json:"topicId"`
	State         PubsubEventState `json:"state"`
	CloudeventsID string           `json:"cloudeventsId"`
	Message       json.RawMessage  `json:"message"`
	Headers       json.RawMessage  `json:"headers"`
}

// ClaimNextEvent atomically claims the next pending event for processing using UPDATE SKIP LOCKED
// to avoid lock contention. It finds the oldest pending event (or retry-ready event), marks it as
// 'active', and returns the event data only.
func (q *Queries) ClaimNextEvent(ctx context.Context, topicID int64) (ClaimNextEventRow, error) {
	row := q.db.QueryRowContext(ctx, claimNextEvent, topicID)
	var i ClaimNextEventRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.TopicID,
		&i.State,
		&i.CloudeventsID,
		&i.Message,
		&i.Headers,
	)
	return i, err
}

const cleanupOldDeadLetters = `-- name: CleanupOldDeadLetters :exec
DELETE FROM pubsub_dead_letters
WHERE id IN (
  SELECT dl.id
  FROM pubsub_dead_letters dl
  JOIN pubsub_events e ON dl.event_id = e.id
  JOIN pubsub_topics t ON e.topic_id = t.id
  WHERE dl.created_at < CURRENT_TIMESTAMP - t.dlq_max_age
)
`

// CleanupOldDeadLetters removes dead letter entries that have exceeded their max age.
func (q *Queries) CleanupOldDeadLetters(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldDeadLetters)
	return err
}

const clearStuckEvents = `-- name: ClearStuckEvents :one
SELECT pubsub_clear_stuck_events($1, $2, $3) as cleared_count
`

// ClearStuckEvents transitions stuck active events back to pending state.
// This is used to recover from crashed subscribers that left events in active state.
func (q *Queries) ClearStuckEvents(ctx context.Context, topicID int64, count int64, olderThan Duration) (int64, error) {
	row := q.db.QueryRowContext(ctx, clearStuckEvents, topicID, count, olderThan)
	var cleared_count int64
	err := row.Scan(&cleared_count)
	return cleared_count, err
}

const completeEvent = `-- name: CompleteEvent :one
SELECT pubsub_complete_event($1) as success
`

// CompleteEvent marks an event as successfully processed.
func (q *Queries) CompleteEvent(ctx context.Context, eventID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, completeEvent, eventID)
	var success bool
	err := row.Scan(&success)
	return success, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO pubsub_topics (name, max_retries, initial_backoff, backoff_max, backoff_multiplier, dlq_enabled, dlq_max_age)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (name) DO UPDATE SET
  max_retries = EXCLUDED.max_retries,
  initial_backoff = EXCLUDED.initial_backoff,
  backoff_max = EXCLUDED.backoff_max,
  backoff_multiplier = EXCLUDED.backoff_multiplier,
  dlq_enabled = EXCLUDED.dlq_enabled,
  dlq_max_age = EXCLUDED.dlq_max_age
RETURNING id, created_at, name, max_retries, initial_backoff, backoff_max, backoff_multiplier, dlq_enabled, dlq_max_age
`

type CreateTopicParams struct {
	Name              string   `json:"name"`
	MaxRetries        int64    `json:"maxRetries"`
	InitialBackoff    Duration `json:"initialBackoff"`
	BackoffMax        Duration `json:"backoffMax"`
	BackoffMultiplier float64  `json:"backoffMultiplier"`
	DlqEnabled        bool     `json:"dlqEnabled"`
	DlqMaxAge         Duration `json:"dlqMaxAge"`
}

// CreateTopic creates or updates a topic with the given configuration.
func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (PubsubTopic, error) {
	row := q.db.QueryRowContext(ctx, createTopic,
		arg.Name,
		arg.MaxRetries,
		arg.InitialBackoff,
		arg.BackoffMax,
		arg.BackoffMultiplier,
		arg.DlqEnabled,
		arg.DlqMaxAge,
	)
	var i PubsubTopic
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.MaxRetries,
		&i.InitialBackoff,
		&i.BackoffMax,
		&i.BackoffMultiplier,
		&i.DlqEnabled,
		&i.DlqMaxAge,
	)
	return i, err
}

const deadLetterCount = `-- name: DeadLetterCount :one
SELECT COUNT(*) as count FROM pubsub_dead_letters
`

func (q *Queries) DeadLetterCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, deadLetterCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deadLetterEvent = `-- name: DeadLetterEvent :one
SELECT pubsub_dead_letter_event($1, $2) as success
`

// DeadLetterEvent immediately sends an event to the dead letter queue and marks it as failed.
// This bypasses retry logic and is useful for events that should not be retried.
func (q *Queries) DeadLetterEvent(ctx context.Context, eventID int64, errorMessage string) (bool, error) {
	row := q.db.QueryRowContext(ctx, deadLetterEvent, eventID, errorMessage)
	var success bool
	err := row.Scan(&success)
	return success, err
}

const deleteDeadLetter = `-- name: DeleteDeadLetter :one
SELECT pubsub_delete_dead_letter($1) as success
`

// DeleteDeadLetter deletes a dead-lettered event by its CloudEvents ID.
// This completely removes the event and all its references from the database,
// but only if the event is currently in the dead letter queue.
func (q *Queries) DeleteDeadLetter(ctx context.Context, cloudeventsID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, deleteDeadLetter, cloudeventsID)
	var success bool
	err := row.Scan(&success)
	return success, err
}

const deleteEvent = `-- name: DeleteEvent :one
SELECT pubsub_delete_event($1) as success
`

// DeleteEvent completely removes an event and all its references from the database.
// This is useful for cleanup operations or when events should be permanently removed.
func (q *Queries) DeleteEvent(ctx context.Context, eventID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, deleteEvent, eventID)
	var success bool
	err := row.Scan(&success)
	return success, err
}

const failEvent = `-- name: FailEvent :one
SELECT pubsub_fail_event($1, $2)::pubsub_fail_action as action_taken
`

// FailEvent handles event failure with configurable retry logic and dead lettering.
// It checks the topic's retry configuration and current retry count to determine if the
// event should be retried (with exponential backoff) or dead lettered. Returns the action
// taken: 'retrying' (event moved to pending with next_attempt time), 'dead_lettered'
// (moved to dead letter queue), or 'failed' (marked as failed without dead lettering).
func (q *Queries) FailEvent(ctx context.Context, eventID int64, errorMessage string) (PubsubFailAction, error) {
	row := q.db.QueryRowContext(ctx, failEvent, eventID, errorMessage)
	var action_taken PubsubFailAction
	err := row.Scan(&action_taken)
	return action_taken, err
}

const getEventStats = `-- name: GetEventStats :one
SELECT
  COUNT(*) FILTER (WHERE e.state = 'pending') as pending_count,
  COUNT(*) FILTER (WHERE e.state = 'retry') as retry_count,
  COUNT(*) FILTER (WHERE e.state = 'active') as active_count,
  COUNT(*) FILTER (WHERE e.state = 'succeeded') as succeeded_count,
  COUNT(*) FILTER (WHERE e.state = 'failed') as failed_count,
  COUNT(*) FILTER (WHERE e.state = 'active' AND e.last_updated < (CURRENT_TIMESTAMP - $1::INTERVAL)) as stuck_count,
  COUNT(dl.id) as dead_letter_count
FROM pubsub_events e
LEFT JOIN pubsub_dead_letters dl ON e.id = dl.event_id
WHERE e.topic_id = $2
`

type GetEventStatsRow struct {
	PendingCount    int64 `json:"pendingCount"`
	RetryCount      int64 `json:"retryCount"`
	ActiveCount     int64 `json:"activeCount"`
	SucceededCount  int64 `json:"succeededCount"`
	FailedCount     int64 `json:"failedCount"`
	StuckCount      int64 `json:"stuckCount"`
	DeadLetterCount int64 `json:"deadLetterCount"`
}

// GetEventStats returns comprehensive statistics for a topic.
func (q *Queries) GetEventStats(ctx context.Context, stuckThreshold Duration, topicID int64) (GetEventStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getEventStats, stuckThreshold, topicID)
	var i GetEventStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.RetryCount,
		&i.ActiveCount,
		&i.SucceededCount,
		&i.FailedCount,
		&i.StuckCount,
		&i.DeadLetterCount,
	)
	return i, err
}

const getPendingEventCount = `-- name: GetPendingEventCount :one
SELECT COUNT(*) as count
FROM pubsub_events e
LEFT JOIN pubsub_retries r ON e.id = r.event_id
WHERE e.state IN ('pending', 'retry')
  AND e.topic_id = $1
  AND (r.id IS NULL OR r.next_attempt <= CURRENT_TIMESTAMP)
`

// GetPendingEventCount returns the number of events ready for processing in a topic.
func (q *Queries) GetPendingEventCount(ctx context.Context, topicID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingEventCount, topicID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTopicByName = `-- name: GetTopicByName :one
SELECT id, created_at, name, max_retries, initial_backoff, backoff_max, backoff_multiplier, dlq_enabled, dlq_max_age FROM pubsub_topics WHERE name = $1
`

// GetTopicByName retrieves a topic by its name.
func (q *Queries) GetTopicByName(ctx context.Context, name string) (PubsubTopic, error) {
	row := q.db.QueryRowContext(ctx, getTopicByName, name)
	var i PubsubTopic
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.MaxRetries,
		&i.InitialBackoff,
		&i.BackoffMax,
		&i.BackoffMultiplier,
		&i.DlqEnabled,
		&i.DlqMaxAge,
	)
	return i, err
}

const listDeadLetters = `-- name: ListDeadLetters :many
SELECT
  dl.id as dead_letter_id,
  dl.created_at as dead_letter_created_at,
  dl.error_message,
  e.id as event_id,
  e.created_at as event_created_at,
  e.cloudevents_id,
  e.message,
  e.headers,
  t.name as topic_name
FROM pubsub_dead_letters dl
JOIN pubsub_events e ON dl.event_id = e.id
JOIN pubsub_topics t ON e.topic_id = t.id
ORDER BY dl.created_at DESC
LIMIT $2 OFFSET $1
`

type ListDeadLettersRow struct {
	DeadLetterID        int64           `json:"deadLetterId"`
	DeadLetterCreatedAt time.Time       `json:"deadLetterCreatedAt"`
	ErrorMessage        string          `json:"errorMessage"`
	EventID             int64           `json:"eventId"`
	EventCreatedAt      time.Time       `json:"eventCreatedAt"`
	CloudeventsID       string          `json:"cloudeventsId"`
	Message             json.RawMessage `json:"message"`
	Headers             json.RawMessage `json:"headers"`
	TopicName           string          `json:"topicName"`
}

// ListDeadLetters returns dead-lettered events with pagination, ordered by creation time (newest first).
func (q *Queries) ListDeadLetters(ctx context.Context, offsetCount int32, limitCount int32) ([]ListDeadLettersRow, error) {
	rows, err := q.db.QueryContext(ctx, listDeadLetters, offsetCount, limitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDeadLettersRow
	for rows.Next() {
		var i ListDeadLettersRow
		if err := rows.Scan(
			&i.DeadLetterID,
			&i.DeadLetterCreatedAt,
			&i.ErrorMessage,
			&i.EventID,
			&i.EventCreatedAt,
			&i.CloudeventsID,
			&i.Message,
			&i.Headers,
			&i.TopicName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishEvent = `-- name: PublishEvent :one
SELECT pubsub_publish_event($1, $2, $3, $4) as event_id
`

// PublishEvent publishes a new event to the specified topic and returns the event ID.
func (q *Queries) PublishEvent(ctx context.Context, topicID int64, cloudeventsID string, message json.RawMessage, headers json.RawMessage) (int64, error) {
	row := q.db.QueryRowContext(ctx, publishEvent,
		topicID,
		cloudeventsID,
		message,
		headers,
	)
	var event_id int64
	err := row.Scan(&event_id)
	return event_id, err
}

const retryDeadLetterEvent = `-- name: RetryDeadLetterEvent :one
SELECT pubsub_retry_dead_letter_event($1) as success
`

// RetryDeadLetterEvent clears the retry state for a dead-lettered event and returns it to pending state.
// This allows failed events to be retried by removing them from the dead letter queue and resetting their state.
func (q *Queries) RetryDeadLetterEvent(ctx context.Context, cloudeventsID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, retryDeadLetterEvent, cloudeventsID)
	var success bool
	err := row.Scan(&success)
	return success, err
}
