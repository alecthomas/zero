//go:build postgres

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package internal

import (
	"context"
	"encoding/json"
	"time"
)

const claimNextEvent = `-- name: ClaimNextEvent :one
SELECT
  id::BIGINT,
  created_at::TIMESTAMP,
  last_updated::TIMESTAMP,
  topic_id::BIGINT,
  state::pubsub_event_state,
  cloudevents_id::VARCHAR(64),
  message::JSONB,
  headers::JSONB
FROM pubsub_claim_next_event($1)
`

type ClaimNextEventRow struct {
	ID            int64
	CreatedAt     time.Time
	LastUpdated   time.Time
	TopicID       int64
	State         PubsubEventState
	CloudeventsID string
	Message       json.RawMessage
	Headers       json.RawMessage
}

// ClaimNextEvent atomically claims the next pending event for processing using UPDATE SKIP LOCKED
// to avoid lock contention. It finds the oldest pending event (or retry-ready event), marks it as
// 'active', and returns the event data only.
func (q *Queries) ClaimNextEvent(ctx context.Context, topicID int64) (ClaimNextEventRow, error) {
	row := q.db.QueryRowContext(ctx, claimNextEvent, topicID)
	var i ClaimNextEventRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastUpdated,
		&i.TopicID,
		&i.State,
		&i.CloudeventsID,
		&i.Message,
		&i.Headers,
	)
	return i, err
}

const cleanupOldDeadLetters = `-- name: CleanupOldDeadLetters :exec
DELETE FROM pubsub_dead_letters
WHERE id IN (
  SELECT dl.id
  FROM pubsub_dead_letters dl
  JOIN pubsub_events e ON dl.event_id = e.id
  JOIN pubsub_topics t ON e.topic_id = t.id
  WHERE dl.created_at < CURRENT_TIMESTAMP - t.dlq_max_age
)
`

// CleanupOldDeadLetters removes dead letter entries that have exceeded their max age.
func (q *Queries) CleanupOldDeadLetters(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupOldDeadLetters)
	return err
}

const clearStuckEvents = `-- name: ClearStuckEvents :one
SELECT pubsub_clear_stuck_events($1, $2, $3) as cleared_count
`

// ClearStuckEvents transitions stuck active events back to pending state.
// This is used to recover from crashed subscribers that left events in active state.
func (q *Queries) ClearStuckEvents(ctx context.Context, topicID int64, count int64, olderThan Duration) (int64, error) {
	row := q.db.QueryRowContext(ctx, clearStuckEvents, topicID, count, olderThan)
	var cleared_count int64
	err := row.Scan(&cleared_count)
	return cleared_count, err
}

const completeEvent = `-- name: CompleteEvent :one
SELECT pubsub_complete_event($1) as success
`

// CompleteEvent marks an event as successfully processed.
func (q *Queries) CompleteEvent(ctx context.Context, eventID int64) (bool, error) {
	row := q.db.QueryRowContext(ctx, completeEvent, eventID)
	var success bool
	err := row.Scan(&success)
	return success, err
}

const createTopic = `-- name: CreateTopic :one
INSERT INTO pubsub_topics (name, max_retries, initial_backoff, backoff_max, backoff_multiplier, dlq_enabled, dlq_max_age)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (name) DO UPDATE SET
  max_retries = EXCLUDED.max_retries,
  initial_backoff = EXCLUDED.initial_backoff,
  backoff_max = EXCLUDED.backoff_max,
  backoff_multiplier = EXCLUDED.backoff_multiplier,
  dlq_enabled = EXCLUDED.dlq_enabled,
  dlq_max_age = EXCLUDED.dlq_max_age
RETURNING id, created_at, name, max_retries, initial_backoff, backoff_max, backoff_multiplier, dlq_enabled, dlq_max_age
`

type CreateTopicParams struct {
	Name              string
	MaxRetries        int64
	InitialBackoff    Duration
	BackoffMax        Duration
	BackoffMultiplier float64
	DlqEnabled        bool
	DlqMaxAge         Duration
}

// CreateTopic creates or updates a topic with the given configuration.
func (q *Queries) CreateTopic(ctx context.Context, arg CreateTopicParams) (PubsubTopic, error) {
	row := q.db.QueryRowContext(ctx, createTopic,
		arg.Name,
		arg.MaxRetries,
		arg.InitialBackoff,
		arg.BackoffMax,
		arg.BackoffMultiplier,
		arg.DlqEnabled,
		arg.DlqMaxAge,
	)
	var i PubsubTopic
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.MaxRetries,
		&i.InitialBackoff,
		&i.BackoffMax,
		&i.BackoffMultiplier,
		&i.DlqEnabled,
		&i.DlqMaxAge,
	)
	return i, err
}

const failEvent = `-- name: FailEvent :one
SELECT pubsub_fail_event($1, $2)::pubsub_fail_action as action_taken
`

// FailEvent handles event failure with configurable retry logic and dead lettering.
// It checks the topic's retry configuration and current retry count to determine if the
// event should be retried (with exponential backoff) or dead lettered. Returns the action
// taken: 'retrying' (event moved to pending with next_attempt time), 'dead_lettered'
// (moved to dead letter queue), or 'failed' (marked as failed without dead lettering).
func (q *Queries) FailEvent(ctx context.Context, eventID int64, errorMessage string) (PubsubFailAction, error) {
	row := q.db.QueryRowContext(ctx, failEvent, eventID, errorMessage)
	var action_taken PubsubFailAction
	err := row.Scan(&action_taken)
	return action_taken, err
}

const getEventStats = `-- name: GetEventStats :one
SELECT
  COUNT(*) FILTER (WHERE e.state = 'pending') as pending_count,
  COUNT(*) FILTER (WHERE e.state = 'active') as active_count,
  COUNT(*) FILTER (WHERE e.state = 'succeeded') as succeeded_count,
  COUNT(*) FILTER (WHERE e.state = 'failed') as failed_count,
  COUNT(*) FILTER (WHERE e.state = 'active' AND e.last_updated < (CURRENT_TIMESTAMP - $1::INTERVAL)) as stuck_count,
  COUNT(dl.id) as dead_letter_count
FROM pubsub_events e
LEFT JOIN pubsub_dead_letters dl ON e.id = dl.event_id
WHERE e.topic_id = $2
`

type GetEventStatsRow struct {
	PendingCount    int64
	ActiveCount     int64
	SucceededCount  int64
	FailedCount     int64
	StuckCount      int64
	DeadLetterCount int64
}

// GetEventStats returns comprehensive statistics for a topic.
func (q *Queries) GetEventStats(ctx context.Context, stuckThreshold Duration, topicID int64) (GetEventStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getEventStats, stuckThreshold, topicID)
	var i GetEventStatsRow
	err := row.Scan(
		&i.PendingCount,
		&i.ActiveCount,
		&i.SucceededCount,
		&i.FailedCount,
		&i.StuckCount,
		&i.DeadLetterCount,
	)
	return i, err
}

const getPendingEventCount = `-- name: GetPendingEventCount :one
SELECT COUNT(*) as count
FROM pubsub_events e
LEFT JOIN pubsub_retries r ON e.id = r.event_id
WHERE e.state = 'pending'
  AND e.topic_id = $1
  AND (r.id IS NULL OR r.next_attempt <= CURRENT_TIMESTAMP)
`

// GetPendingEventCount returns the number of events ready for processing in a topic.
func (q *Queries) GetPendingEventCount(ctx context.Context, topicID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, getPendingEventCount, topicID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTopicByName = `-- name: GetTopicByName :one
SELECT id, created_at, name, max_retries, initial_backoff, backoff_max, backoff_multiplier, dlq_enabled, dlq_max_age FROM pubsub_topics WHERE name = $1
`

// GetTopicByName retrieves a topic by its name.
func (q *Queries) GetTopicByName(ctx context.Context, name string) (PubsubTopic, error) {
	row := q.db.QueryRowContext(ctx, getTopicByName, name)
	var i PubsubTopic
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.Name,
		&i.MaxRetries,
		&i.InitialBackoff,
		&i.BackoffMax,
		&i.BackoffMultiplier,
		&i.DlqEnabled,
		&i.DlqMaxAge,
	)
	return i, err
}

const publishEvent = `-- name: PublishEvent :one
SELECT pubsub_publish_event($1, $2, $3, $4) as event_id
`

// PublishEvent publishes a new event to the specified topic and returns the event ID.
func (q *Queries) PublishEvent(ctx context.Context, topicID int64, cloudeventsID string, message json.RawMessage, headers json.RawMessage) (int64, error) {
	row := q.db.QueryRowContext(ctx, publishEvent,
		topicID,
		cloudeventsID,
		message,
		headers,
	)
	var event_id int64
	err := row.Scan(&event_id)
	return event_id, err
}
