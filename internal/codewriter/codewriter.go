// Package codewriter is a simple helper for writing out source code.
package codewriter

import (
	"bytes"
	"fmt"
	"io"
	"sort"
	"strings"
)

type Writer struct {
	imports *[]string
	prelude []*Writer
	trailer []*Writer
	w       *bytes.Buffer
	pkg     string
	indent  string
}

func New(pkg string) *Writer {
	return &Writer{w: &bytes.Buffer{}, pkg: pkg, imports: &[]string{}}
}

// W writes a formatted string directly to the writer without indentation or newline.
func (c *Writer) W(format string, args ...any) {
	fmt.Fprintf(c.w, format, args...)
}

// L writes a newline-terminated string to the writer.
func (c *Writer) L(format string, args ...any) {
	c.W(c.indent+format+"\n", args...)
}

// In calls "fn" with a Writer that is indented one level.
func (c *Writer) In(fn func(w *Writer)) {
	fn(c.Push())
}

// Indent writes the current indent level without a newline.
func (c *Writer) Indent() {
	c.W("%s", c.indent)
}

// Push returns a Writer indented one level.
func (c *Writer) Push() *Writer {
	out := *c
	out.indent += "\t"
	return &out
}

// Pop returns a Writer unindented one level.
func (c *Writer) Pop() *Writer {
	out := *c
	out.indent = out.indent[:len(out.indent)-2]
	return &out
}

// Body returns the body of the code, without the package declaration and imports.
func (c *Writer) Body() string {
	out := &bytes.Buffer{}
	c.writeBody(out)
	return out.String()
}

// Import adds an import to the generated code.
func (c *Writer) Import(pkgs ...string) {
	for _, pkg := range pkgs {
		if pkg != "" {
			*c.imports = append(*c.imports, pkg)
		}
	}
}

func (c *Writer) Prelude() *Writer {
	out := &Writer{imports: c.imports, w: &bytes.Buffer{}}
	c.prelude = append(c.prelude, out)
	return out
}

// Trailer returns a Writer that will be appended to the end of the code.
//
// Useful for writing out helper functions and other globals.
func (c *Writer) Trailer() *Writer {
	out := &Writer{imports: c.imports, w: &bytes.Buffer{}}
	c.trailer = append(c.trailer, out)
	return out
}

// String returns the self-contained complete generated code.
func (c *Writer) String() string {
	out := &strings.Builder{}
	c.write(out)
	return out.String()
}

// Bytes returns the self-contained complete generated code.
func (c *Writer) Bytes() []byte {
	out := &bytes.Buffer{}
	c.write(out)
	return out.Bytes()
}

//nolint:errcheck
func (c *Writer) write(w io.Writer) {
	for _, prelude := range c.prelude {
		prelude.writeBody(w)
	}
	fmt.Fprintf(w, "// Code generated by zero. DO NOT EDIT.\n")
	fmt.Fprintf(w, "package %s\n", c.pkg)
	fmt.Fprintf(w, "\n")
	imports := []string{}
	seen := map[string]bool{}
	for _, pkg := range *c.imports {
		key := strings.Trim(pkg, "\"")
		if key == "" || seen[key] {
			continue
		}
		seen[key] = true
		imports = append(imports, pkg)
	}
	sort.Strings(imports)
	if len(imports) > 0 {
		fmt.Fprintf(w, "import (\n")
		for _, pkg := range imports {
			if strings.HasSuffix(pkg, "\"") {
				fmt.Fprintf(w, "  %s\n", pkg)
			} else {
				fmt.Fprintf(w, "  %q\n", pkg)
			}
		}
		fmt.Fprintf(w, ")\n")
		fmt.Fprintf(w, "\n")
	}
	io.Copy(w, c.w)
	for _, trailer := range c.trailer {
		trailer.writeBody(w)
	}
}

//nolint:errcheck
func (c *Writer) writeBody(w io.Writer) {
	io.Copy(w, c.w)
	for _, trailer := range c.trailer {
		fmt.Fprintln(w, trailer.Body())
	}
}
