// Code generated by zero. DO NOT EDIT.
package main

import (
  "context"
  "fmt"
  "github.com/alecthomas/zero"
  impc24ab568b6f3f934 "github.com/alecthomas/zero/providers/sql"
  impe1d11ad6baa4124f "database/sql"
  "net/http"
  "reflect"
)

// Config contains combined Kong configuration for all types in [Construct].
type ZeroConfig struct {
	Config9c6b7595816de4c ServiceConfig `embed:""`
	Config6fab5aa5f9534d38 impc24ab568b6f3f934.Config `embed:""`
}

// Construct an instance of T.
func ZeroConstruct[T any](ctx context.Context, config ZeroConfig) (out T, err error) {
	return ZeroConstructSingletons[T](ctx, config, map[reflect.Type]any{})
}

// ZeroConstructSingletons constructs a new instance of T, or returns an instance of T from "singletons" if already constructed.
func ZeroConstructSingletons[T any](ctx context.Context, config ZeroConfig, singletons map[reflect.Type]any) (out T, err error) {
	if singleton, ok := singletons[reflect.TypeFor[T]()]; ok {
		return singleton.(T), nil
	}
	defer func() { singletons[reflect.TypeFor[T]()] = out }()
	switch any(out).(type) {
	case context.Context:
		return any(ctx).(T), nil

	case *impc24ab568b6f3f934.Config: // Handle pointer to config.
		return any(&config.Config6fab5aa5f9534d38).(T), nil

	case impc24ab568b6f3f934.Config:
		return any(config.Config6fab5aa5f9534d38).(T), nil

	case *ServiceConfig: // Handle pointer to config.
		return any(&config.Config9c6b7595816de4c).(T), nil

	case ServiceConfig:
		return any(config.Config9c6b7595816de4c).(T), nil

	case *Service:
		if p0, err := ZeroConstructSingletons[*DAL](ctx, config, singletons); err != nil {
			return out, err
		} else 		if p1, err := ZeroConstructSingletons[ServiceConfig](ctx, config, singletons); err != nil {
			return out, err
		} else if o, err := NewService(p0, p1); err != nil {
			return out, fmt.Errorf("NewService: %w", err)
		} else {
			return any(o).(T), nil
		}

	case *DAL:
		if p0, err := ZeroConstructSingletons[*impe1d11ad6baa4124f.DB](ctx, config, singletons); err != nil {
			return out, err
		} else if o, err := NewDAL(p0); err != nil {
			return out, fmt.Errorf("NewDAL: %w", err)
		} else {
			return any(o).(T), nil
		}

	case *impe1d11ad6baa4124f.DB:
		if p0, err := ZeroConstructSingletons[impc24ab568b6f3f934.Config](ctx, config, singletons); err != nil {
			return out, err
		} else if o, err := impc24ab568b6f3f934.New(p0); err != nil {
			return out, fmt.Errorf("New: %w", err)
		} else {
			return any(o).(T), nil
		}

	case *http.ServeMux:
		r0, err := ZeroConstructSingletons[*Service](ctx, config, singletons)
		if err != nil {
			return out, fmt.Errorf("*http.ServeMux: %w", err)
		}
		mux := http.NewServeMux()
		mux.HandleFunc("GET /users", func(w http.ResponseWriter, r *http.Request) {
			out, herr := r0.ListUsers()
			_ = zero.EncodeResponse[[]User](r, w, out, herr)
		})
		mux.HandleFunc("POST /users", func(w http.ResponseWriter, r *http.Request) {
			p0, err := zero.DecodeRequest[User]("POST", r)
			if err != nil {
				http.Error(w, fmt.Sprintf("Invalid request: %s", err), http.StatusBadRequest)
				return
			}
			herr := r0.CreateUser(p0)
			_ = zero.EncodeResponse[zero.EmptyResponse](r, w, nil, herr)
		})
		mux.HandleFunc("GET /users/{id}", func(w http.ResponseWriter, r *http.Request) {
			p0 := r.PathValue("id")
			out, herr := r0.GetUser(p0)
			_ = zero.EncodeResponse[User](r, w, out, herr)
		})
		return any(mux).(T), nil

	}
	return out, fmt.Errorf("don't know how to construct %T", out)
}
