// Code generated by zero. DO NOT EDIT.
package main

import (
  "database/sql"
  "context"
  "fmt"
  "github.com/alecthomas/zero"
  "github.com/alecthomas/zero/providers/cron"
  "github.com/alecthomas/zero/providers/pubsub"
  "golang.org/x/sync/errgroup"
  imp31feb4b39618eab1 "github.com/alecthomas/zero/providers/logging"
  imp3773070ca4e7a2b8 "github.com/alecthomas/zero/providers/http"
  imp71bef56b62085424 "github.com/alecthomas/zero/providers/cron"
  imp897f1a742b20547b "github.com/alecthomas/zero/providers/pubsub/postgres"
  imp9b258f273adc01df "github.com/alecthomas/zero/providers/leases"
  imp9c34c006eb3c10fa "github.com/alecthomas/zero"
  impc24ab568b6f3f934 "github.com/alecthomas/zero/providers/sql"
  "log/slog"
  "net/http"
  "reflect"
  "time"
)

// Config contains combined Kong configuration for all types constructable by the [Injector].
type ZeroConfig struct {
	Configcb396d0960e493ec imp3773070ca4e7a2b8.Config `embed:"" prefix:"server-"`
	Configef92e6d1a86c2c7f imp31feb4b39618eab1.Config `embed:"" prefix:"log-"`
	Config6fab5aa5f9534d38 impc24ab568b6f3f934.Config `embed:"" prefix:"sql-"`
}

// Injector contains the constructed dependency graph.
type Injector struct {
	config     ZeroConfig
	singletons map[reflect.Type]any
}

// NewInjector creates a new Injector with the given context and configuration.
func NewInjector(ctx context.Context, config ZeroConfig) *Injector {
	return &Injector{config: config, singletons: map[reflect.Type]any{}}
}

// RegisterHandlers registers all Zero handlers with the injector's [http.ServeMux].
func RegisterHandlers(ctx context.Context, injector *Injector) error {
	r0, err := ZeroConstructSingletons[*Service](ctx, injector)
	if err != nil {
		return fmt.Errorf("*Service: %w", err)
	}
	mux, err := ZeroConstructSingletons[*http.ServeMux](ctx, injector)
	if err != nil {
		return err
	}
	_ = mux
	logger, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
	if err != nil {
		return err
	}
	_ = logger
	encodeError, err := ZeroConstructSingletons[zero.ErrorEncoder](ctx, injector)
	if err != nil {
		return err
	}
	encodeResponse, err := ZeroConstructSingletons[zero.ResponseEncoder](ctx, injector)
	if err != nil {
		return err
	}
	_ = encodeError
	_ = encodeResponse
	mux.Handle("GET /users", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		out, herr := r0.ListUsers()
		encodeResponse(logger, r, w, encodeError, out, herr)
	}))
	// Parameters for the Authenticate middleware
	m0p0 := "admin"
	mux.Handle("POST /users", Authenticate(m0p0)(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		p0, err := zero.DecodeRequest[User]("POST", r)
		if err != nil {
			encodeError(logger, w, fmt.Sprintf("invalid request: %s", err), http.StatusBadRequest)
			return
		}
		herr := r0.CreateUser(p0)
		encodeResponse(logger, r, w, encodeError, nil, herr)
	})))
	mux.Handle("GET /users/{id}", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		p0 := r.PathValue("id")
		out, herr := r0.GetUser(p0)
		encodeResponse(logger, r, w, encodeError, out, herr)
	}))
	return nil
}

// RegisterSubscribers registers all Zero PubSub subscribers with their topics.
func RegisterSubscribers(ctx context.Context, injector *Injector) error {
	r0, err := ZeroConstructSingletons[*Service](ctx, injector)
	if err != nil {
		return fmt.Errorf("*Service: %w", err)
	}
	topic82018cb5695fd1d2, err := ZeroConstructSingletons[pubsub.Topic[UserCreatedEvent]](ctx, injector)
	if err != nil {
		return err
	}
	if err := topic82018cb5695fd1d2.Subscribe(ctx, r0.OnUserCreated); err != nil {
		return fmt.Errorf("failed to subscribe to topic for OnUserCreated: %w", err)
	}
	return nil
}
// Run the Zero server container.
//
// This registers all request handlers, cron jobs, PubSub subscribers, etc.
func Run(ctx context.Context, config ZeroConfig) error {
	injector := NewInjector(ctx, config)
	if err := RegisterHandlers(ctx, injector); err != nil {
		return fmt.Errorf("failed to register handlers: %w", err)
	}
	if err := RegisterSubscribers(ctx, injector); err != nil {
		return fmt.Errorf("failed to register subscribers: %w", err)
	}
	server, err := ZeroConstructSingletons[*http.Server](ctx, injector)
	if err != nil {
		return err
	}
	cron, err := ZeroConstructSingletons[*cron.Scheduler](ctx, injector)
	if err != nil {
		return err
	}
	r0, err := ZeroConstructSingletons[*Service](ctx, injector)
	if err != nil {
		return err
	}
	err = cron.Register("github.com/alecthomas/zero/_examples/service.Service.CheckUsersCron", time.Duration(5000000000), r0.CheckUsersCron)
	if err != nil {
		return fmt.Errorf("failed to register cron job github.com/alecthomas/zero/_examples/service.Service.CheckUsersCron: %w", err)
	}
	wg, ctx := errgroup.WithContext(ctx)
	logger, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
	if err != nil {
		return err
	}
	logger.Info("Server starting", "bind", server.Addr)
	wg.Go(func() error { return server.ListenAndServe() })
	return wg.Wait()
}

// Construct an instance of T.
func ZeroConstruct[T any](ctx context.Context, config ZeroConfig) (out T, err error) {
	injector := NewInjector(ctx, config)
	return ZeroConstructSingletons[T](ctx, injector)
}

// ZeroConstructSingletons constructs a new instance of T, or returns an instance of T from the injector if already constructed.
func ZeroConstructSingletons[T any](ctx context.Context, injector *Injector) (out T, err error) {
	if singleton, ok := injector.singletons[reflect.TypeFor[T]()]; ok {
		return singleton.(T), nil
	}
	defer func() { injector.singletons[reflect.TypeFor[T]()] = out }()
	switch reflect.TypeOf((*T)(nil)).Elem() {
	case reflect.TypeOf((*context.Context)(nil)).Elem():
		return any(ctx).(T), nil

	case reflect.TypeOf((**imp3773070ca4e7a2b8.Config)(nil)).Elem(): // Handle pointer to config.
		return any(&injector.config.Configcb396d0960e493ec).(T), nil

	case reflect.TypeOf((*imp3773070ca4e7a2b8.Config)(nil)).Elem():
		return any(injector.config.Configcb396d0960e493ec).(T), nil

	case reflect.TypeOf((**imp31feb4b39618eab1.Config)(nil)).Elem(): // Handle pointer to config.
		return any(&injector.config.Configef92e6d1a86c2c7f).(T), nil

	case reflect.TypeOf((*imp31feb4b39618eab1.Config)(nil)).Elem():
		return any(injector.config.Configef92e6d1a86c2c7f).(T), nil

	case reflect.TypeOf((**impc24ab568b6f3f934.Config)(nil)).Elem(): // Handle pointer to config.
		return any(&injector.config.Config6fab5aa5f9534d38).(T), nil

	case reflect.TypeOf((*impc24ab568b6f3f934.Config)(nil)).Elem():
		return any(injector.config.Config6fab5aa5f9534d38).(T), nil

	case reflect.TypeOf((**sql.DB)(nil)).Elem():
		p0, err := ZeroConstructSingletons[context.Context](ctx, injector)
		if err != nil {
			return out, err
		}
		p1, err := ZeroConstructSingletons[impc24ab568b6f3f934.Config](ctx, injector)
		if err != nil {
			return out, err
		}
		p2, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		p3, err := ZeroConstructSingletons[impc24ab568b6f3f934.Migrations](ctx, injector)
		if err != nil {
			return out, err
		}
		o, err := impc24ab568b6f3f934.New(p0, p1, p2, p3)
		if err != nil {
			return out, fmt.Errorf("*sql.DB: %w", err)
		}
		return any(o).(T), nil

	case reflect.TypeOf((**DAL)(nil)).Elem():
		p0, err := ZeroConstructSingletons[*sql.DB](ctx, injector)
		if err != nil {
			return out, err
		}
		o := NewDAL(p0)
		return any(o).(T), nil

	case reflect.TypeOf((**Service)(nil)).Elem():
		p0, err := ZeroConstructSingletons[*DAL](ctx, injector)
		if err != nil {
			return out, err
		}
		p1, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		o, err := NewService(p0, p1)
		if err != nil {
			return out, fmt.Errorf("*Service: %w", err)
		}
		return any(o).(T), nil

	case reflect.TypeOf((**imp71bef56b62085424.Scheduler)(nil)).Elem():
		p0, err := ZeroConstructSingletons[context.Context](ctx, injector)
		if err != nil {
			return out, err
		}
		p1, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		p2, err := ZeroConstructSingletons[imp9b258f273adc01df.Leaser](ctx, injector)
		if err != nil {
			return out, err
		}
		o := imp71bef56b62085424.NewScheduler(p0, p1, p2)
		return any(o).(T), nil

	case reflect.TypeOf((**slog.Logger)(nil)).Elem():
		p0, err := ZeroConstructSingletons[imp31feb4b39618eab1.Config](ctx, injector)
		if err != nil {
			return out, err
		}
		o := imp31feb4b39618eab1.ProvideLogger(p0)
		return any(o).(T), nil

	case reflect.TypeOf((**http.ServeMux)(nil)).Elem():
		o := imp3773070ca4e7a2b8.DefaultServeMux()
		return any(o).(T), nil

	case reflect.TypeOf((**http.Server)(nil)).Elem():
		p0, err := ZeroConstructSingletons[context.Context](ctx, injector)
		if err != nil {
			return out, err
		}
		p1, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		p2, err := ZeroConstructSingletons[imp3773070ca4e7a2b8.Config](ctx, injector)
		if err != nil {
			return out, err
		}
		p3, err := ZeroConstructSingletons[*http.ServeMux](ctx, injector)
		if err != nil {
			return out, err
		}
		o := imp3773070ca4e7a2b8.DefaultServer(p0, p1, p2, p3)
		return any(o).(T), nil

	case reflect.TypeOf((*imp9c34c006eb3c10fa.ErrorEncoder)(nil)).Elem():
		o := imp3773070ca4e7a2b8.DefaultErrorEncoder()
		return any(o).(T), nil

	case reflect.TypeOf((*imp9c34c006eb3c10fa.ResponseEncoder)(nil)).Elem():
		o := imp3773070ca4e7a2b8.DefaultResponseEncoder()
		return any(o).(T), nil

	case reflect.TypeOf((*imp9b258f273adc01df.Leaser)(nil)).Elem():
		p0, err := ZeroConstructSingletons[context.Context](ctx, injector)
		if err != nil {
			return out, err
		}
		p1, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		p2, err := ZeroConstructSingletons[impc24ab568b6f3f934.Driver](ctx, injector)
		if err != nil {
			return out, err
		}
		p3, err := ZeroConstructSingletons[*sql.DB](ctx, injector)
		if err != nil {
			return out, err
		}
		o, err := imp9b258f273adc01df.NewSQLLeaser(p0, p1, p2, p3)
		if err != nil {
			return out, fmt.Errorf("imp9b258f273adc01df.Leaser: %w", err)
		}
		return any(o).(T), nil

	case reflect.TypeOf((*impc24ab568b6f3f934.Driver)(nil)).Elem():
		p0, err := ZeroConstructSingletons[impc24ab568b6f3f934.Config](ctx, injector)
		if err != nil {
			return out, err
		}
		o, err := impc24ab568b6f3f934.DriverForConfig(p0)
		if err != nil {
			return out, fmt.Errorf("impc24ab568b6f3f934.Driver: %w", err)
		}
		return any(o).(T), nil

	case reflect.TypeOf((*impc24ab568b6f3f934.Migrations)(nil)).Elem():
		r0 := imp9b258f273adc01df.SQLLeaserMigrations()
		r1 := imp897f1a742b20547b.Migrations()
		r2 := Migrations()
		var result impc24ab568b6f3f934.Migrations
		result = append(result, r0...)
		result = append(result, r1...)
		result = append(result, r2...)
		return any(result).(T), nil


	}
	return out, fmt.Errorf("don't know how to construct %s", reflect.TypeFor[T]())
}
