// Code generated by zero. DO NOT EDIT.
package main

import (
  "context"
  "fmt"
  "golang.org/x/sync/errgroup"
  imp31feb4b39618eab1 "github.com/alecthomas/zero/providers/logging"
  imp71bef56b62085424 "github.com/alecthomas/zero/providers/cron"
  imp9b258f273adc01df "github.com/alecthomas/zero/providers/leases"
  imp9c34c006eb3c10fa "github.com/alecthomas/zero"
  "log/slog"
  "net/http"
  "reflect"
  "time"
)

// Config contains combined Kong configuration for all types constructable by the [Injector].
type ZeroConfig struct {
	Configef92e6d1a86c2c7f imp31feb4b39618eab1.Config `embed:"" prefix:"log-"`
}

// Injector contains the constructed dependency graph.
type Injector struct {
	config     ZeroConfig
	singletons map[reflect.Type]any
}

// NewInjector creates a new Injector with the given context and configuration.
func NewInjector(ctx context.Context, config ZeroConfig) *Injector {
	return &Injector{config: config, singletons: map[reflect.Type]any{}}
}

// RegisterHandlers registers all Zero handlers with the injector's [http.ServeMux].
func RegisterHandlers(ctx context.Context, injector *Injector) error {
	mux, err := ZeroConstructSingletons[*http.ServeMux](ctx, injector)
	if err != nil {
		return err
	}
	_ = mux
	logger, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
	if err != nil {
		return err
	}
	_ = logger
	encodeError, err := ZeroConstructSingletons[imp9c34c006eb3c10fa.ErrorEncoder](ctx, injector)
	if err != nil {
		return err
	}
	encodeResponse, err := ZeroConstructSingletons[imp9c34c006eb3c10fa.ResponseEncoder](ctx, injector)
	if err != nil {
		return err
	}
	_ = encodeError
	_ = encodeResponse
	return nil
}

// RegisterSubscribers registers all Zero PubSub subscribers with their topics.
func RegisterSubscribers(ctx context.Context, injector *Injector) error {
	return nil
}
// Run the Zero server container.
//
// This registers all request handlers, cron jobs, PubSub subscribers, etc.
func Run(ctx context.Context, config ZeroConfig) error {
	injector := NewInjector(ctx, config)
	if err := RegisterHandlers(ctx, injector); err != nil {
		return fmt.Errorf("failed to register handlers: %w", err)
	}
	if err := RegisterSubscribers(ctx, injector); err != nil {
		return fmt.Errorf("failed to register subscribers: %w", err)
	}
	server, err := ZeroConstructSingletons[*http.Server](ctx, injector)
	if err != nil {
		return err
	}
	cron, err := ZeroConstructSingletons[*imp71bef56b62085424.Scheduler](ctx, injector)
	if err != nil {
		return err
	}
	r0, err := ZeroConstructSingletons[*CronJobs](ctx, injector)
	if err != nil {
		return err
	}
	err = cron.Register("*github.com/alecthomas/zero/_examples/cron.CronJobs.Ping", time.Duration(5000000000), r0.Ping)
	if err != nil {
		return fmt.Errorf("failed to register cron job *github.com/alecthomas/zero/_examples/cron.CronJobs.Ping: %w", err)
	}
	wg, ctx := errgroup.WithContext(ctx)
	logger, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
	if err != nil {
		return err
	}
	logger.Info("Server starting", "bind", server.Addr)
	wg.Go(func() error { return server.ListenAndServe() })
	return wg.Wait()
}

// Construct an instance of T.
func ZeroConstruct[T any](ctx context.Context, config ZeroConfig) (out T, err error) {
	injector := NewInjector(ctx, config)
	return ZeroConstructSingletons[T](ctx, injector)
}

// ZeroConstructSingletons constructs a new instance of T, or returns an instance of T from the injector if already constructed.
func ZeroConstructSingletons[T any](ctx context.Context, injector *Injector) (out T, err error) {
	if singleton, ok := injector.singletons[reflect.TypeFor[T]()]; ok {
		return singleton.(T), nil
	}
	defer func() { injector.singletons[reflect.TypeFor[T]()] = out }()
	switch reflect.TypeOf((*T)(nil)).Elem() {
	case reflect.TypeOf((*context.Context)(nil)).Elem():
		return any(ctx).(T), nil

	case reflect.TypeOf((**imp31feb4b39618eab1.Config)(nil)).Elem(): // Handle pointer to config.
		return any(&injector.config.Configef92e6d1a86c2c7f).(T), nil

	case reflect.TypeOf((*imp31feb4b39618eab1.Config)(nil)).Elem():
		return any(injector.config.Configef92e6d1a86c2c7f).(T), nil

	case reflect.TypeOf((**CronJobs)(nil)).Elem():
		p0, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		o := NewCronJobs(p0)
		return any(o).(T), nil

	case reflect.TypeOf((**imp71bef56b62085424.Scheduler)(nil)).Elem():
		p0, err := ZeroConstructSingletons[context.Context](ctx, injector)
		if err != nil {
			return out, err
		}
		p1, err := ZeroConstructSingletons[*slog.Logger](ctx, injector)
		if err != nil {
			return out, err
		}
		p2, err := ZeroConstructSingletons[imp9b258f273adc01df.Leaser](ctx, injector)
		if err != nil {
			return out, err
		}
		o := imp71bef56b62085424.NewScheduler(p0, p1, p2)
		return any(o).(T), nil

	case reflect.TypeOf((**slog.Logger)(nil)).Elem():
		p0, err := ZeroConstructSingletons[imp31feb4b39618eab1.Config](ctx, injector)
		if err != nil {
			return out, err
		}
		o := imp31feb4b39618eab1.ProvideLogger(p0)
		return any(o).(T), nil

	case reflect.TypeOf((*imp9b258f273adc01df.Leaser)(nil)).Elem():
		o := imp9b258f273adc01df.NewMemoryLeaser()
		return any(o).(T), nil


	}
	return out, fmt.Errorf("don't know how to construct %s", reflect.TypeFor[T]())
}
